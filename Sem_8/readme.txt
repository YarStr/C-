<< Задача Сol23 >>
Дан массив целых чисел длины N, упорядоченный строго по возрастанию, и целое число X. Найти в массиве любые два различных элемента с суммой X,
совершая при этом менее квадратичного числа операций (то есть быстрее, чем перебор всех пар элементов).
Запрещается использовать встроенные коллекции (Dictionary, HashSet и т.п.).

Решение.
Т.к. массив изначально отсортирован, то для ускорения работы программы начинаем итерацию c конца массива и идем к его началу.
Если взятое число(i) меньше, чем искомая сумма (X), и его удвоение превышает искомую сумму (X), то с начала массива начинаем поиск второго(j) слагаемого.
Если парное число(j) найдено, то на экран выводится эта пара чисел, программа завершает свою работу. В случае, когда взятое число(i) не превышает искомую сумму(X)
при умножении на два, т.к. массив отсортирован по возрастанию, можно сказать, что в нём не найдётся пара чисел, равная искомой сумме – любые комбинации будут давать
меньший результат (число(j) <= число(i)).


<< Задача Rec1 >>
Возвести число в натуральную степень P за Θ(logP). Рекурсивный и нерекурсивный варианты.

Решение.
В основе решения лежит идея, которую можно сформулировать так:
- Если степень P чётная, то x^P можно найти как x^P = x^(P/2) * x^(P/2)
- Если степень P нечётная, то x^P можно найти как x^P = x * x^(P-1) = x * x^( (P-1)/2 ) * x^( (P-1)/2 )
Именно эти математические соображения позволяют уменьшить сложность алгоритма до необходмой.

В функции main() заправивается степень(P), в которую будет возводиться число, затем вызывается рекурсивная и нерекурсивная функции.
Обе функции сводят вычисление степени к вышеописанным опирациям с меньшими степенями и, последовательно умножая получаемые значения,
возвращают искомую степень числа.
